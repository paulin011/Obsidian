{"path":"Softwaretechnik/Lectures/07_Programming, Paradigms, Languages.pdf","text":"Software Engineering Programming, Paradigms and Languages There will be slides that explicitly ask you to ask questions. Nonetheless, you are welcome to ask questions anytime in between as well. 3 Structure of the OOSE Lectures Revisit and deepen basics of programming. Revisit and deepen basics of object-oriented programming. Cover advanced object-oriented principles. How to model OO systems (UML) and map models to code. Object-oriented modeling techniques. Design patterns as means to realize OO concepts (I). Design patterns as means to realize OO concepts (II). ↓ 4 Last Lecture • Component diagrams. • Architectural patterns: Layers, publish-subscribe, microservices, model-view-controller. • API. 5 Aims of this Lecture • Overview of programming paradigms and languages. • Revisit imperative concepts. • Introduce \"under the hood\" principles. • Revisit object-oriented programming basics. Paradigms and Languages 7 Programming Paradigms and Languages In general, we can differentiate between two major approaches to program construction: Imperative Programming The focus lies on the \"how\", i.e., the developer provides specific step-by-step instructions how to achieve a desired result. Declarative Programming The focus lies on the \"what\", i.e., the developer describes characteristics of the result, and the machine finds a way to achieve this result. public static void bubbleSort(int[] arr) { int n = arr.length; for (int i = 0; i < n - 1; i++) { for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp } } } } bubble_sort([],Sorted) :- Sorted = []. bubble_sort([X], Sorted) :- Sorted = [X]. bubble_sort(Terms, Sorted) :- bubble(Terms, Terms), Sorted = Terms ; bubble(Terms, Partials), bubble_sort(Partials, Sorted). bubble([], Bubbled) :- Bubbled = []. bubble([X], Bubbled) :- Bubbled = [X]. bubble([X,Y|Terms], [Y|Bubbled]) :- Y < X, bubble([X|Terms], Bubbled). bubble([X,Y|Terms], [X|Bubbled]) :- X =< Y, bubble([Y|Terms], Bubbled). bubblesort :: Ord a => [a] -> [a] bubblesort list = case sort list of sortedList | sortedList == list -> list | otherwise -> bubblesort sortedList Where sort (x1:x2:xs) | x1 > x2 = x2 : sort (x1:xs) | otherwise = x1 : sort (x2:xs) sort xs = xs 9 Programming Languages Until today, there are thousands of languages and only a fraction of them are used for more then ten years. Languages that were in use for more than 25 years include Ada, C, C++, COBOL, Java, Objective C, PL/I, SQL, Visual Basic, ... Brief History • 1949: assembly language • 1954: first high-level language FORTRAN (Formula Translator) by IBM • 1959: functional language Lisp • 1967: first object-oriented lang. Simula • 1972: logical language Prolog • 1972: procedural language C • 1973: declarative domain-specific lang. SQL • 1985: C++ as object-oriented extension of C • 1990: functional language Haskell • 1991: multi-paradigm language Python • 1995: scripting language JavaScript • 1996: primarily object-oriented language Java • 2002: C# by Microsoft • 2009: Go by Google • 2014: Swift by Apple • 2015: Rust by Mozilla Research 10 Programming Language Popularity (TIOBE Index) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 11 Choice of Programming Languages Choosing the right language involves many aspects and decisions, but it is usually best to go with a language that is neither dead nor brand new and covers many use cases in the development. Desired Properties [Ludewig and Lichter] • Modular implementation • Separation of interfaces and implementations • Type system: statically/dynamically typed languages • Readable syntax (FORTRAN vs. ALGOL60) • Automatic pointer management (C vs. Java) • Exception handling Criteria in Practice • Language required by the company or customer? • Existing infrastructure? • Domain-specific languages available? • Language known/liked by developers? • Available libraries? • Available tool support? • Language popularity? • What may change in the future? 12 Programming Language Efficiency Questions? Executable Programs 15 From Source Code to Executable Programs Programming Languages are translated to machine code via compilers (and linkers). • Lexical analysis (Scanner): Identify Tokens. • Syntactical analysis: Create abstract syntax tree (AST). • Semantic analysis: Refine AST. • Synthesis: Create target code using AST and mapping rules.Analysis Source Code Lexical Analysis Syntactic Analysis Semantic Analysis Target Code Synthesis Intermediate Code 16 Compilation #include<stdio.h> int main() { printf(\"Hello :)\"); } hello.c NULNULNULNULNULNULNULNUL NULNULNULNULNUL \"Hello :)\"NULNULNULNUL hello.exe source code, src Executable file 001010100110101010100101 010101010100101111010101 010101010101110111010101 110010110101010111110011 Process 957 Machine code in RAM. OS loads the program and starts a process. Compiler Compiler compiles source code into an executable file. 17 Compilation of Partly-Compiled Languages VM interprets bytecode and creates machine code. void main() { System.out .println(\"Hello :)\"); } Hello.java class Hello { Main(); 0: aload_0 1: invokespecial #1 4: return void main(); 0: aload_0 1: ldc #7 3: invokevirtual #9 6: return } Hello.class source code, src Bytecode program 001010100110101010100101 010101010100101111010101 010101010101110111010101 110010110101010111110011 Process 957 Machine code in RAM. OS loads a virtual machine (VM) that loads the bytecode. Compiler Compiler compiles source code into bytecode. Questions? Imperative Programming Crash Course for students of the Java Programming Course https://www.giga.de/spiele/star-wars- battlefront/tipps/star-wars-battlefront- imperator-guide-so-raeumt-ihr-mit- palpatine-auf/ 20 Imperative Programming: Overview The term imperative Programming usually covers multiple paradigms: • \"Pure\" imperative programming / unstructured programming. • Structured Programming. • Procedural Programming. • Modular Programming. • Object-Oriented Programming. We will go through these paradigms and see how they map to Java. We assume you are familiar with the concepts these paradigms provide, even if you were not familiar with the naming. This is why we do not go into details here. 21 \"Pure\" Imperative Programming / Unstructured Programming Unstructured Programming involves the fundamental concepts of programming: variables and operations. • Declaration of a variable: • Types define how to interpret a bitstring in memory. Primitive types in Java: boolean, char, byte, short, int, long, float, double. • Operators are expressions comprising multiple part-expressions to yield a value: • Operations in Java: +, -, *, /, %, =, ~, ^, |, &, ||, &&, >>, >>>, <<, ++, --, !, <, >, ==, <=, >=, !=, ○= [modifiers] <type> <variable identifier> [= initial value]; float salary = 2750.0f; <operator><expression> //unary <expression><operator><expression> //binary 22 Structured Programming Structured programming introduces control flow structures, i.e., branching and looping. • Conditional branching: if(condition) { //code } else if(condition2) { //code } //... else { //code } switch(var) { case 0: { ...; break; } case 1: { ...; break; } case 2: { ...; break; } case 3: { ...; break; } case 4: { ...; break; } case 5: case 6: case 7: case 8: { ...; break; } default: { ...; } } Pioneered by David Parnas and Edsger Dijkstra, see \"goto considered harmful\". 23 Structured Programming Structured programming introduces control flow structures, i.e., branching and looping. • Loops: • Interrupting loops: • Terminate enclosing loop: • Jump to next iteration of enclosing loop: while(condition) { //code } do { //code } while (condition) for(init; condition; update) { //code } for(<type> element: collection) { //code } break label; continue label; 24 Procedural Programming Procedural programming takes structural programming to another level: We define named blocks of code, procedures, to which we can jump by calling them. • Calling a procedure: • Procedures with return type void do not return any value. They are only sensible if they perform any kind of side effect: state change, printing to console, writing to file. • Procedures with any other return type compute a result: • return is the last executed instruction in a procedure. Any instruction after that in the control flow is unreachable. returnType procedureIdentifier(type1 para1, type2 para2) { //code } return <value>; myProcedure(1, \"hey\", true) 25 Modular Programming Modular Programming concerns with the decomposition of code into modules. In Java, there are three levels of modules: classes, packages and modules (which should be named components). de.unikoeln A.java B.java C.java package de.unikoeln.mainlogic.subpkg2; subpkg2 mainlogic subpkgD.java E.java F.java G.java Questions? Memory Management 28 Process Memory Layout Stack The stack memory is used for storing values of local variables and expressions. Heap The heap memory is used to store objects (more on that later). The other segments of a processes' memory are not relevant for us and will therefore be referred to as static memory in the upcoming lectures. OS Stack Free Memory Shared Libraries / Memory Free Memory Heap .bss Segment .data Segment .text Segment BIOS 29 Argument Passing We call procedures via their identifier and pass arguments (actual values) for their parameters. Throughout different programming languages, there are different argument passing mechanisms. • Call by value: the arguments are evaluated before being passed to the procedure. The passing happens via copying the value. By this, it is not possible to change, e.g., a variable passed as argument outside the procedure. This is what Java uses. • Call by reference: The parameter becomes an alias for the argument. Thus, it is possible to change the original value from within the procedure. • Others, not as common. myProcedure(a, \"hey\", true) 30 Call by Value Passing The value of arguments is copied to the parameters (which act as local variables of the procedure). Changing the value of the parameters does not affect the original variables. int pow(int x) { int result = x * x; x += 5; return result * x; } int x = 5; println(pow(x)); //250 println(x); //5 0xA7 5 (x) 0xA6 0xA5 0xA4 rdi rax Stack evolution over time 5 (x) return address base pointer 25 (result = x * x) 10 (x) 250 (result * x) 5 (x) return address base pointer 25 (result = x * x) 10 (x) 5 (x) return address base pointer 25 (result = x * x) 5 (x) 5 (x) return address base pointer 5 (x) 31 Iteration vs. Recursion Iteration and Recursion are two principals of repeating the same set of instructions. Iteration uses loops; recursion is the self call of a procedure. Iteration is faster and is stable in memory usage. Recursion can be dangerous in terms of memory usage but allows for better parallelization. Plus, recursion is the only way to loop in strictly functional programming languages. while(condition) { //code } returnType name(type1 para1) { //code name(x); } 32 Iteration vs. Recursion: The Stack Memory Iteration overrides the same cells on the stack its body is using in each iteration. void factorial(int n) { int result = n; for(int i = 1; i < n; i++) result *= i; return result; } Ret F00xA2 result0xA1 int f = factorial(10); //<- Ret F0 i0xA0 = n = 1 = n*1 = 2 = n*1*2 = 3 = n*1*2*3 = 4 It. 1 It. 2 It. 3 It. 4 33 Iteration vs. Recursion: The Stack Memory Recursion, being based on function calls, always creates a new stack frame, thus possibly causing a stack overflow error. int factorial(int n) { int result = n; if(n==0) return 1; return result * factorial(n – 1); //<- Ret F1 } Ret F00xA7 result (n)0xA6 \"int factorial(int n - 1) { int result = n - 1; if(n==0) return 1; return result * factorial(n – 2); //<- Ret F2 }\" int f = factorial(10); //<- Ret F0 Ret F10xA5 result (n - 1)0xA4 \"int factorial(int n - 2) { int result = n - 2; if(n==0) return 1; return result * factorial(n – 3); //<- Ret F3 }\" ... Ret F20xA3 result (n - 2)0xA2 Ret F30xA1 …0xA0 Stackframe \"n\" Stackframe \"n-1\" Stackframe \"n-2\" Questions? Objects and Classes 36 Objects Objects are dynamically created, encapsulated units of data (variables, its state) and operations (methods, its behavior). The state of an object is time dependent • State = Values of variables. • State in 𝑡𝑡𝑖𝑖 = Values of variables in 𝑡𝑡𝑖𝑖. The behavior of an object is the set of reactions to operation invocations (→ methods). • Self-state-transition. • Invocation of operations of other objects. firstname lastname matNumber age 37 OOP Terminology Message: Operation invocation / method call. Operation: The parts of a method visible to the outside. Method: The body of a method. public void setRecord(Grade grade, Module module) { ... this.records.add(grade, module, MainSystem.currentDate()); ... } public void setRecord(Grade grade, Module module) student.setRecord(Grade.get(\"1.0\"), softwareEngineering); Receiver of the message Message 38 Objects Encapsulation • The language ensures that state transitions are only triggered via the provided interfaces. • If the interface stays the same, changes in the implementation won't affect other objects. Interface of an object • Set of callable operations for a set of users. • Different users may be presented different interfaces. firstname lastname matNumber age 39 How are Objects Created? In class-based languages: Specification through \"writing it down\": Variables and Methods can be specified per type of object (→ in its class). Creation through instantiation: • Objects are created through a special operation, called constructor. • The class is a template for its objects. • Objects created from a class are called instances of the class. print() getName() getMatNum() <<instance of>> <<instance of>> <<instance of>> firstname lastname matNumber age firstname lastname matNumber age firstname lastname matNumber age firstname lastname matNumber age 40 Classes: Example A class describes a set of \"similar\" objects • Same interface • Same attributes • Same operations • Same method implementations • Different values of variablesStructurally equal class Student { String firstname; String lastname; int age; int matriculationNumber; Student(String firstname, String lastname, int age, int matNumber) { this.age = age; this.firstname = firstname; this.lastname = lastname; this.matriculationNumber = matNumber; } void print() { System.out.println(this.firstname + \" \" + this.lastname + \", \" + this.age + \", \" + this.matriculationNumber); } ... } 41 Classes: Instantiation The expression new Student(…)creates a new instance of type Student and takes as value the reference to the instance. firstname \"Adrian\" lastname \"Bajraktari\" age 26 matriculation- Number 2969443 Student adrian = new Student(\"Adrian\", \"Bajraktari\", 26, 2969443); class Student { String firstname; String lastname; int age; int matriculationNumber; Student(String firstname, String lastname, int age, int matNumber) { this.age = age; this.firstname = firstname; this.lastname = lastname; this.matriculationNumber = matNumber; } void print() { System.out.println(this.firstname + \" \" + this.lastname + \", \" + this.age + \", \" + this.matriculationNumber); } ... } 42 Messages adrian.setAge(27); class Student { String firstname; String lastname; int age; int matriculationNumber; Student(String firstname, String lastname, int age, int matNumber) { this.age = age; this.firstname = firstname; this.lastname = lastname; this.matriculationNumber = matNumber; } void print() { System.out.println(this.firstname + \" \" + this.lastname + \", \" + this.age + \", \" + this.matriculationNumber); } ... } In the object-oriented world, invocating/calling a method is also called a message. firstname \"Adrian\" lastname \"Bajraktari\" age 26 matriculation- Number 2969443 27 43 Accessing Instance Members Access to instance members is done via the following scheme: • Access to instance variables: • Access to instance methods: It is generally considered bad coding style to directly access an objects attributes. Instead: Define methods that encapsulate the access: • Getter methods to get the variables value. • Setter methods to set the variables value. Attention: objectRef.operation(arg1,..., argn) objectRef.attribute Student adrian = null; int a = adrian.age; adrian.print(); Access to members via a reference to null causes a NullPointerException to be thrown! 44 Class Methods and Variables Class methods work independent of instances. They are called via a class directly. • Keyword static • Semantic: Class variables are the same for all instances of a class. Invocation: class Student { static Student[] studentList = new Student[10]; ... static int getNumberOfStudents() { return studentList.length; } ... } int numberVar = Student.studentlist.length; int numberMet = Student.getNumberOfStudents(); 45 Visibilities: Overview The following shows which visibility modifier applies to which level. This applies to classes, methods, constructors and attributes. Attention! Visibility is neither access control, nor mutability! Visible in: public protected package-private private Own class Own package Subclasses Globally Questions? 47 Summary In today's lecture: • General programming paradigms and languages. • Imperative programming concepts. • Memory management. • Basics of object-oriented programming. Use this knowledge when developing code, in your job as well as in the exercises.","libVersion":"0.2.4","langs":""}