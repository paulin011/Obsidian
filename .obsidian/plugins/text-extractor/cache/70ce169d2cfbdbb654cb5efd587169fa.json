{"path":"Statistik/Softwaretechnik/Lectures/15_SEforWebApps II.pdf","text":"Software Engineering SE for Web Applications II: Frontend Software & Systems Engineering | Prof. Dr. Andreas Vogelsang | 29.11.2023 @andivogelsang vogelsang@cs.uni-koeln.de Learning Goals for Today ▪ Know how web content can be represented in a browser (via HTML, JavaScript, and DOM) ▪ Know how to manipulate content on web pages ▪ Know how to make asynchronous calls (to a backend) ▪ Understand how web frontend frameworks work ▪ Understand the Model-View-ViewModel pattern ▪ Understand the interplay between data and design/output and how binding can enable reactive frontends 2HTML HTML 4 Hyper Text Markup Language (HTML) • Standardized by the W3C • Describes structure and content of a document • Human and non-human users • Browser parses the content and presents it to the end user • Crawler indexes the parsed content (machine-readability) HTML Structure 5 Head with meta data • Title • Data from meta element • Author, Keywords, Date, … • Linking to other resources • CSS, JavaScript, … Body containing content Global attributes (excerpt) • id: Unique identifier • class: Assigned class for CSS • title: Description of an element • style: Element-specific layout information • data-*: Invisible attached data (Custom data accessible through JavaScript) HTML Structure – Element Semantics 6 Syntax Semantics Not given by standard visual representation! • <h1> is a first order header != the thickest printed text • <b> prints text bold != <em> emphasizes the text • <table> represents tabular data != layout mechanism Why use syntactically and semantically correct elements? • Browser compatibility, accessibility • Easier processing for tools, e.g., transformations, indexing for search engines • More efficient browsing (no interpretation of wrong HTML necessary) • Shift towards better use of semantics enables • Ability for better interpretation for accessibility • Easier code understanding and maintainability HTML Structure – Content Structure 7 Content Structure • <header> defines header of document or section • <nav> defines navigation region of page or section • <main> main content of the page • <section> thematic grouping of content • <h1-h6> Heading from most to least important. Reflects structural depth, e.g. in sections. Exactly one <h1> per page • <article> specifies complete, self-contained content • <aside> defines content aside from main content • <footer> defines footer of document or section <header> <nav> <section> <article> <article> <article> <footer> <aside> Many of these elements can be nested and it's not always straightforward which element should be used! HTML Elements 8 Generic elements • <div> Generic block element • <span> Generic inline element Use these when no other element with more appropriate semantics is left Grouping elements • <p> paragraphs • <ul> unordered list • <ol> ordered list • <table> tabular data Links and anchors • <a> Link to another page or location HTML Basic Forms 9 Input • Checkboxes • Radio Buttons • Menus • Text fields • Text area • Buttons What happens when I send a form? 10 <html> <head> <title>Simple Form</title> </head> <body> <p>Please fill the form</p> <form action=“/processForm” method=“post”> <p> <label for=“username”>Your name:</label> <input type=“text” id=“username” name=“username” /> </p> <p><input type=“submit” value=“Submit the form” name=“action” /> </p> </form> </body> </html> HTML forms only allow POST and GET requests What happens when I send a form? 11 Andreas1 2 Client HTTP Server … userName=“Andreas” POST request Message Body 3 4 … userName=“Andreas” Program response.html 6 5 response.html submit.html response.html 7 DOM and Asynchronous Requests Document Object Model 13 Document Object Model (DOM) • Tree structure for interacting with (X)HTML and XML documents • HTML elements as objects with properties, methods and events • Standardized by the W3C • Platform- and language-independent Document Object Model 14 DOM Operators • Retrieve Elements • Change Elements • Content, attributes, style, class • Manipulating DOM nodes • Create, append, remove • DOM traversal on elements • parentElement, nextElementSibling, previousElementSibling, childNodes Event-driven and Asynchronous Programming 15 Event-driven Programming • Flow of the program is determined by responding to user actions called events • Writing programs driven by user events DOM Events 16 Event callback attached to HTML elements Event types (selection) • load/unload: User enters/leaves a page • change: Form input field changes • Focus/blur: User focuses/unfocuses an input field • submit: Form is submitted • mouseover/mouseout: Mouse enters/leaves region • mousedown/mouseup/click: Mouse click events • Keydown/keyup/keypress: Keyboard events • drag: User drags an elements Sending Asynchronous Requests (Callbacks) 17 Classic network request API (XMLHttpRequest) • Used callbacks - a mechanism to provide a function that gets called once you receive a response from HTTP • Callbacks resulted in increasingly nested callback chains dubbed “callback hell”: http://callbackhell.com/ Sending Asynchronous Requests (Promises) 18 fetch API fetch API allows processing HTTP requests/ responses using promises: • Promises are a general wrapper around asynchronous computations and callbacks • They represent how to get a value - you tell it what to do as soon as it receives the value • A promise is a proxy object for a value that is not yet known. It is modeled with the following states • Pending (initial state) • Fulfilled (execution successful) • Rejected (operation failed) Sending Asynchronous Requests (async/wait) 19 async/await is a special syntax to work with promises • async is a keyword around a function that wraps a promise around its return value. • await is a keyword that makes JavaScript wait until the promise is resolved and can then return the value (only works within async functions!) https://javascript.info/async-await Sending Asynchronous Requests (Observables) 20 Observables are an extension to promises • Offered by the RxJS library; heavily used e.g., in Angular • Promises deal with one asynchronous event at a time, while observables handle a sequence of asynchronous events over a period of time Promises Observables Emit a single value at a time. Emit multiple values over a period of time. Are not lazy: execute immediately after creation. Are lazy: they’re not executed until we subscribe to them using the subscribe() method. Are not cancellable. Have subscriptions that are cancellable using the unsubscribe() method, which stops the listener from receiving further values. Don’t provide any operations. Provide the map for forEach, filter, reduce, retry, and retryWhen operators. Push errors to the child promises. Deliver errors to the subscribers. Sending Asynchronous Requests (Observables) 21 Operations Promises Observables Creation const promise = new Promise(() => { resolve(10); }); const obs = new Observable((observer) => { observer.next(10); }) ; Transform promise.then((value) => value * 2); Obs.pipe(map(value) => value * 2); Subscribe promise.then((value) => { console.log(value) }); const sub = obs.subscribe((value) => { console.log(value) }); Unsubscribe N/A sub.unsubscribe(); Abstractions in Web Frontends Frontend Abstractions 23 facilitated through Routing (Single Page Applications) Components Encapsulation Data Binding Data Encapsulation One-way binding Style Encapsulation Two-way binding Templates State Management Behavior Encapsulation Declarative Rendering Enables modularization and reusability by encapsulating various aspects of the component Establishes declarative relationship between components and models Frontend Architecture 24 Model-View-ViewModel (MVVM) A design pattern often used in frontends Model: Data access layer for data that is shown to the user and can be manipulated View: Structure, layout, and appearance of what a user sees on the screen ViewModel: Contains the UI logic and connects the view with the model. Data Binding: Declarative binding between view and view model. View View Model Model Data Binding Frontend Backend Model Controller ViewNaming gets confusing • Backend model vs. frontend model • Backend controller vs. frontend controller • Backend service vs. frontend service MVVM in Angular 25 Files formats Model: A class defined in TypeScript (usually only attributes and no methods) View: An HTML template ViewModel: A TypeScript class containing event- handling behavior Data Binding: • Property Binding: Binding (changing) data to UI elements) • Event Binding: Binding events in the view to actions in the ViewModel Services: A TypeScript class containing supporting and reusable (across ViewModels) functionality Frontend Components 26 Frontend Components Components are reusable building blocks • Template HTML code in View • Declares binding to internal model and properties through interpolations; Syntax: {{data}} • Supports bounded loops and conditional rendering • Behavior in ViewModel • Input parameters that become part of the internal model (properties) • Functions to deal with event handling (methods) • Encapsulate (scoped) styles that are bound to the component Frontend Templates (View) 27 Templating Template engines replace variables in static template files and control structures (conditionals and loops) with values passed from the program. Backend vs. frontend templating Backend Templates • The backend receives a request, retrieves/computes data, and generates HTML files • Templates are static markup files that are expanded based on data/values • Template variables are replaced with values • Loops: Iterate over lists of values and generate HTML for each instance • Conditionals: Generate different HTML depending on values Frontend Templates • Conceptually very similar to backend templates (template variables, loops, conditionals) • Reactive: Values might change based on model changes • Model changes can be triggered by user input • Model (changes) can be retrieved from backend • DOM is updated Data Binding 28 One-Way Binding Declares binding to internal model and properties • Bindings as part of DOM content nodes are declared through interpolation syntax: {{ data }} • (Interpolations are inline expressions, i.e., can be any JavaScript code) • Bindings as part of attributes are defined using directives (property binding) <img [src]=“standardImage”> • One-way refers to the direction of data- flow Values from the model and properties are bound to the template variables to create the output when expanded <div> // interpolation <a href=\"{{ link }}\">{{ pizza.name }}</a> <p>Ingredients: {{ pizza.ingredients.join(', ') }}</p> </div> <div> // property binding <img [src]=\"link\"> <p>Pepperoni Pizzeria!</p> </div> @Component({ selector: 'app-pizza', templateUrl: './pizza.component.html', styleUrls: ['./pizza.component.css'] }) export class PizzaComponent { link = 'https://pepperoni-pizzeria.com/awesome-pizzas' pizza = { name: 'Pepperoni Pizza', ingredients: ['anchovies', 'tomatoes'] } } Data Binding 29 Two-Way Binding Declares binding to and from the internal model (form inputs) • Model changes are reflected in the view (as in one-way binding) • Changes in the view are reflected in the model (and consequently in all bindings that have been established on the model) • Binding through ngModel directive <input [(ngModel)]=\"name\"> <div class=\"container\"> <input type=\"text\" [(ngModel)]=\"review\"> <p>{{ review }}</p> <button>Submit Review</button> </div> @Component({ selector: \"app-root\", templateUrl: \"./app.component.html\", styleUrls: [\"./app.component.css\"], }) export class AppComponent { review=\"Default review\"; } Data Binding 30 Event Binding Declares reactions to events • Model changes are reflected in the view (as in one-way binding) • Binding through directive <button (click)=\"onSubmit()\" type=\"submit\"> <div> <textarea rows=\"4\" columns=\"50\" [(ngModel)]=\"review\"> Enter review here... </textarea> // event binding! <button (click)=\"onSubmit()\" type=\"submit\"> Submit Review</button> </div> @Component({ selector: 'app-pizzeria', templateUrl: './pizzeria.component.html', styleUrls: ['./pizzeria.component.css'] }) export class PizzeriaComponent { @Output() reviewSubmitted = new EventEmitter<string>(); review = ''; // this method will execute on click onSubmit() { this.reviewSubmitted.emit(this.review); } } @Component({ selector: 'app-root', template: ' <div> <app-pizzeria (reviewSubmitted)=\"onReviewSubmitted($event)\"> </app-pizzeria> </div> ', styleUrls: ['./pizzeria.component.css'] }) export class PizzeriaComponent { reviews = []; onReviewSubmitted(review: string) { this.reviews.push(review); } } Conditional Rendering 31 Conditional Rendering Render elements only if expression evaluates to true • Controlled by directives ng-if and ng-template <ng-container *ngIf=\"isLoggedIn; then loggedIn; else loggedOut\"> </ng-container> <ng-template #loggedIn> <div> Welcome back, friend. </div> </ng-template> <ng-template #loggedOut> <div> Please friend, login. </div> </ng-template> <div *ngIf=\"!isLoggedIn\"> Please login, friend. </div> export class AppComponent { isLoggedIn = true; } Bounded Loops (List Rendering) 32 List Rendering Map elements in an array to HTML elements • Controlled by directive ng-for <table> <thead> <th>Name</th> </thead> <tbody> <tr *ngFor=\"let hero of heroes\"> <td>{{hero.name}}</td> </tr> </tbody> </table> Routing 33 Routing Browser-like navigation for Single-Page Applications • Simulate standard navigation by manipulating the browser history • URL fragments allow linking to different logical “pages” while staying on the same browser page https://www.example.com/#/config/437568 • Router library • Same concept as server-side routing • Can pass URL parts as props to components <li> <a [routerLink]=\"['product']\">Product</a> </li> <router-outlet></router-outlet> Map actions to routes import { Routes } from '@angular/router'; import { HomeComponent} from './home.component' import { ProductComponent} from './product.component' import { ErrorComponent} from './error.component' export const appRoutes: Routes = [ { path: 'home', component: HomeComponent }, { path: 'product', component: ProductComponent }, { path: '', redirectTo: 'home', pathMatch: 'full‘ }, { path: '**', component: ErrorComponent } ]; Deployment 34 Deploying Frontend Applications • Frontent applications themselves need to be served by a web server • Often, these are (virtual) single-page applications • There is only a single html file on the server (index.html) • Every “page-like” navigation is dynamically handled by the application on client-side Deployment in Angular • ng serve runs a local web server that provides the application • ng build creates a set of static files that can hosted on most web servers • ng deploy directly deploys the app to a hosting service (e.g., Amazon Cloud S3, Firebase, GitHub Pages) Testing Web Applications 35 Backend Testing • Unit and integration tests: Standard testing frameworks for the language of the backend • JUnit tests for Java/Spring backends • System Tests: External tools for testing RESTfulAPIs (e.g., via Postman) Frontend Testing • Unit and integration tests: Testing frameworks for frontend frameworks • Jasmine for Angular • System Tests: External tools for testing web GUIs • Work on the HTML elements • Often record-and-playback Frontend Frameworks 36 Endless Variety of Frontend Frameworks • Different philosophies • Different corporate backing • Same concepts and abstractions Summary 37 SE for Web Applications II: Frontend • Websites are written in HMTL • With JavaScript, you can manipulate websites to react to events (user input) • JavaScript is used to define dynamic behavior on websites (incl. calls to a backend) • Web frontends consider the client side of web applications • Modern frontend follow a Model-View-ViewModel architecture (or similar) • Frontend components help creating modular applications","libVersion":"0.3.1","langs":""}