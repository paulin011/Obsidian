{"path":"Statistik/Softwaretechnik/Lectures/10_UML Class and Sequence Diagrams.pdf","text":"Software Engineering Modeling Software with UML Class Diagrams and UML Sequence Diagrams 2 Structure of the OOSE Lectures Revisit and deepen basics of programming. Revisit and deepen basics of object-oriented programming. Cover advanced object-oriented principles. How to model OO systems (UML) and map models to code. Object-oriented modeling techniques. Design patterns as means to realize OO concepts (I). Design patterns as means to realize OO concepts (II). ‚Üì 3 Last Lecture In last lecture: ‚Ä¢ Generic programming. ‚Ä¢ Lambdas and streams. ‚Ä¢ Exception handling. ‚Ä¢ Concurrency via threads. ‚Ä¢ Object-based programming via JavaScript. 4 Aims of this Lecture How to model (OO) systems? ‚Ä¢ Object diagrams for example runtime configurations. ‚Ä¢ Class diagrams for the structure of a system. ‚Ä¢ Sequence diagrams for the behavior of a system. How to map models to code? ‚Ä¢ Class diagrams ‚Üí code. ‚Ä¢ Sequence diagrams ‚Üí code. ‚Ä¢ Activity diagrams ‚Üí code. Object Diagrams alice/StudentBodyChair:Student studentBodyCS:StudentBody andreas/DepartmentHead:ProfessorIn swt:Module cs:Department adrian/Tutor:ScientStaff 6 Objects Objects are represented as rectangles. The name field of objects are underlined and comprise of the following (in this exact order): ‚Ä¢ An Identifier for the instance (optional) ‚Ä¢ A \"/\" followed by the role of this object (optional) ‚Ä¢ A \":\" as divider (mandatory) followed by the Type of the instance (optional) alice:Studentalice/StudentBodyChair:Student :Student 7 Objects The objects' attributes together with their values can be displayed (optional). Methods are not included in an object when using class-based programming languages. :Student age = 21 name = \"alice\" grades = {{\"oose\": 1.0}, {\"swt\": 1.0}} 8 Relations between Objects Relations are displayed using lines or arrows: ‚Ä¢ Directed line (arrow) = specified navigability ‚Ä¢ Undirected line = unspecified navigability Not according to standard, but sometimes helpful: ‚Ä¢ Aggregation and Composition ‚Ä¢ Roles alice/StudentBodyChair:Student studentBodyCS:StudentBody andreas/DepartmentHead:ProfessorIn swt:Module cs:Department adrian/Tutor:ScientStaff Class Diagrams 10 Classes A class represents a concept. A class encapsulates state (attributes) and behavior (operations). The classes' name is the only mandatory aspect. ‚Ä¢ Usually, more information is added during the development process. ‚Ä¢ Information not important to the context may be \"hidden\" (not displayed). Student age: Integer name: String semester: Integer getAge(): Integer getName(): String immatriculate() 11 Attributes Student - age: Integer - name: String - semester: Integer = 1 # instances: Student[*] ‚Ä¶ Visibility Name Type Default value Property/ : = }{ , Min ][ Max.. + public # protected ~ package - private Derived attribute? Non-negative Number with ùëÄùëÄùëÄùëÄùëÄùëÄ ‚â§ ùëÄùëÄùëÄùëÄùëÄùëÄ, or * Any; predefined: {readOnly} {unique} or {non-unique} {ordered} or {unordered} 12 Operations Student ‚Ä¶ ~ getAge(): Integer # getName(): String + immatriculate(s:StudyProgram) # getInstances(): Student[*] Visibility Name Parameter Property( }{) Type Input-, Output-, or Inout- Parameter. : Name Type Default value: = }{ , Min ][ Max.. in out inout , Property , 13 Further Notation What the previous syntax diagrams could not show: ‚Ä¢ Class methods and variables are underlined ‚Ä¢ Abstract classes and methods are in italic ‚Ä¢ Interfaces are annotated with the stereotype <<interface>> and never hold any attributes Mitarbeiter - id: String {unique} + getId(): String Mitarbeiter {abstract} - id: String {unique} + {abstract} getId(): String <<interface>> Person + getName() 14 Implements and Dependency Relation Interface Implementation Class realizes interface Dependency Class depends on other class String ‚Ä¶ isEqual(String): Bool hash(): Integer String ‚Ä¶ isEqual(String): Bool hash(): Integer <<interface>> Hashable <<interface>> Comparable Hashable Comparable HashTable <<uses>> << uses>> HashTable << uses>> 15 Generalization Inheritance: Inherited methods and attributes are not repeated in subclasses. Hiding: Redefined attributes and class methods must be repeated in subclasses. Overriding: Overridden methods are repeated in subclasses. Overloading ‚Ä¢ All different signatures are specified. ‚Ä¢ Overloaded methods can be overridden in subclasses as well! Staff - id: String {unique} - name: String + getId(): String + getName(): String + getSalary(): Money PhD + getSalary(): Money Professor - modules: Module[*] + getSalary(): Money Questions?Associations 18 Associations Associations define relations between instances of classes. Chair Staff employer employeeÔÇÉ works for * * Role of the chair for the employee Multiplicity: any: * fix number: 6 closed interval: 0..1 open interval: 5..* Relation name and direction of reading. Here: \"Staff works for Chair\" Role of Staff for Chair 19 Multiplicities The multiplicity on one end defines with how many instances of the class at this end and instance of the class on the other end can be related. ÔÇÑ Example: N to M association Matching object diagram: Chair Staff employer employeeÔÇÉ works for * * sse:Chair pds:Chair visva:Chair alice:Staff bob:Staff charly:Staff Legal: multiple employees Legal: one employee Legal: no employee Legal: one jobs Legal: multiple jobs Legal: no job 20 Multiplicities The multiplicity on one end defines with how many instances of the class at this end and instance of the class on the other end can be related. ÔÇÑ Example: 1 to N association Illegal object diagram: Instructor ExerciseGroup 1 2..* adrian:Instructor mersedeh:Instructor andreas:Instructor g1:ExerciseGroup g2:ExerciseGroup Illegal: to few exercise groups Illegal: No instructor Illegal: multiple instructors supervises ÔÇÑtutor exercise group 21 Multiplicities The multiplicity on one end defines with how many instances of the class at this end and instance of the class on the other end can be related. ÔÇÑ Example: 1 to 1 association Illegal object diagram: Chair Professor 0..1 1 sse:Chair visva:Chair pds:Chair andreas:Professor tatiana:Professor Illegal: multiple heads Illegal: leads multiple chairs ÔÇÉ leads Illegal: no head chair head Legal: exactly one head Legal: exactly one chair stefan:Professor Legal: leads no chair 22 Roles Roles describe the function of an object within an association ÔÇÑ The same classes can be related via different associations because their instances \"play\" different roles: Lecture Student participant tutor Exam examinee observer 23 Associations: Navigation Unspecified Navigation ‚Ä¢ Syntax: Simple line end without arrow or cross ‚Ä¢ Semantic: ‚Ä¢ Navigation is not (yet) fully specified ‚Ä¢ Navigation might be possible ‚Ä¢ Application: Conceptual view Explicit Navigation ‚Ä¢ Syntax: ‚Ä¢ Arrow (= navigable end) ‚Ä¢ Cross (= non-navigable end) ‚Ä¢ Semantic: ‚Ä¢ Navigation to arrow end possible ‚Ä¢ Navigation to cross end not possible ‚Ä¢ Application: Implementation View 24 Associations: Navigation Unspecified Navigation Partially specified Unidirectional Navigation Bidirectional Navigation Lecturer Student Lecturer Student Lecturer Student Lecturer Student Lecturer Student Lecturer Student \"What's that?\" ‚Üí Hint to association classes Questions?Aggregation and Composition 27 Aggregation Aggregation = \"part of\" ‚Ä¢ The \"part\" may be part of one or many \"wholes\". ‚Ä¢ Lifetime of the \"part\" is not dependent on the \"whole\". Matching object model: StudyProgram Module * * Shared Modules computerscience:StudyProgram businessinformatics:Studyprogram ti:Module swt:Module prog:Module bwl:Module vwl:Module 28 Composition Composition = \"is exclusive and existence-dependent part of\" ‚Ä¢ Part can only be part of at most one whole. ‚Ä¢ Lifetime of the part depends on lifetime of the whole. Example: A chair is part of exactly one Department and cannot exists without it. Matching example of the real world: Department Chair 1 * Department of Computer Science SSE PDS VISVA department chair 29 Hierarchical Composition Composition = \"is exclusive and existence-dependent part of\" ‚Ä¢ Part can only be part of at most one whole ‚Ä¢ Lifetime of the part depends on lifetime of the whole Example: Group can only be part of at most one chair Subgroup is not directly part of a chair ‚Ä¢ Multiplicity ‚Ä¢ Explicit constraints Chair Group 0..1 * Chair of Software and Systems Engineering RE EIS RSE G1 G2 G1 G2 G1 G2 * 0..1 supergroup subgroup { context Group: (chair != null) implies (supergroup = null) } { context Group: (supergroup != null) implies (chair = null) } chair group 30 Hierarchical Composition Composition = \"is exclusive and existence-dependent part of\" ‚Ä¢ Part can only be part of at most one whole ‚Ä¢ Lifetime of the part depends on lifetime of the whole Example: Group can only be part of at most one chair Matching object diagram: SSE:Lehrstuhl RSE:Group EIS:Group RE:Group G1:Group G2:Group G1:Group G2:Group G1:Group G2:Group No aggregation or composition relations allowed to other objects! Chair Group 0..1 * * 0..1 supergroup chair group subgroup Questions? 32 Depiction of Relations ‚Ä¢ Explicit Depiction: ‚Ä¢ Compact depiction: A B C D A B C D A B C D A B C D A B C D A B C D Summary (so far) 34 Class Diagrams: Overview Association ‚Ä¢ Navigation ‚Ä¢ Multiplicities ‚Ä¢ Roles Relation types ‚Ä¢ Generalization ‚Ä¢ Implementation ‚Ä¢ Dependency ‚Ä¢ Association ‚Ä¢ Aggregation ‚Ä¢ Composition << dependency>> * min..* min..max + role Implementation 36 Mapping Diagrams to Code Class without associations Java source code class Student { private int age; private String name; private int semester = 1; protected static Collection<Student> instances; int getAge() { ‚Ä¶ return this.age; } protected String getName() {‚Ä¶} public void enroll() {‚Ä¶} protected static Collection<Student> getInstances() {‚Ä¶} } return this.age; ~ getAge(): Integer # getName(): String + enroll() # getInstance(): Student[*] Student - age: Integer - name: String - semester: Integer = 1 # instance: Student[*] 37 Implementation of Associations In the following slides, we will discuss the mapping of all combinations of navigability and multiplicity of associations We will (most of the time) not make use of any particular programming language, but rather transform diagrams with association into diagrams without. The mapping of a diagram without association has been discussed on the previous slide. 38 Unidirectional Association \"to 1\" Object model with association Object model without association Unidirectional 1:1 and 1:N associations are easy: ‚Ä¢ The not navigable class has a reference to the navigable class ‚Ä¢ The referenced class has no such variable Chair Professor chair headÔÇÉ leads 1 Chair Professor chair: Chair 1 39 Unidirectional Associations 1:N and M:N Object model with association Object model without association Unidirectional 1:N and M:N associations are equally easy: ‚Ä¢ Only difference to previous: referencing class holds a collection of instances of the referenced class ‚Ä¢ In Java, Collection is the interface to classes like List, Set, etc. Chair Staff employer employeeÔÇÉ leads * Chair Staff employees: Staff[*] * 40 Bidirectional Association 1:1 In principle the same as two pointing opposite unidirectional associations. Problem: When setting the reference, we need to make sure the back reference is set as well ‚Ä¢ Both assignments must happen atomically ‚Ä¢ Synchronization in setter methods ‚Üí next slide ‚Ä¢ Basis: synchronized-blocks and methods in Java Chair Professor chair headÔÇÉ leads 0..1 1 - head: Professor Chair - chair: Chair Professor 41 Bidirectional Association 1:1 Object model with association Object model without association + getProf() + setProf(p: Professor) + getChair() + setChair(c: chair) synchronized(this) { head = p; if(p.getChair() != this) p.setChair(this); } synchronized(this) { chair = c; if(c.getProf() != this) c.setProf(this); } Why does this check not suffice? -> Between \"setting here\" and \"setting there\", no other thread may interrupt! Chair Professor chair headÔÇÉ leads 0..1 1 - head: Professor Chair - chair: Chair Professor 42 Bidirectional Association 1:N Object model with association Object model without association Synchronization approach like bidirectional 1:1 case. Student Exam examinee exam 1 * - exams: Exam[*] Student + getExams(): Exam[*] + addExam (e: Exam) + removeExam(e: Exam) - examinee: Student Exam + getExaminee(): Student + setExaminee(s: Student) participates ÔÇÑ 43 Bidirectional Association N:M (na√Øve) Object model with association Object model without association Problem 1: Setting back-references deadlock-free not trivial anymore Problem 2 (of everything so far): The relation is hardcoded into the classes ‚Üí high inter-dependency Chair Staff chair employee * * - employees: Staff[*] Chair + getEmployees(): Staff[*] + addEmployee(e: Staff) + removeEmployee(e: Staff) - chair: Chair[*] Staff + getChairs(): Chair[*] + addChair(c: Chair) + removeChair(c: Chair) ÔÇÉ works at 44 Associations are implicit Classes! An association‚Ä¶ ...and its elements‚Ä¶ ...can be seen as instances of a class \"Contract\" sse: Chair adrian: Staff pds: Chair tim: Staff lisa: Staff c11: Contract chair = sse employee = adrian c12: Contract chair = sse employee = tim c13: Contract chair = sse employee = lisa c21: Contract chair = pds employee = tim c22: Contract chair = pds employee = lisa Chair Staff chair employee * * ÔÇÉ works at 45 Bidirectional Associations N:M (Class) Object model with bidirectional association Object model without bidirectional association Chair Staff - contracts: Contract[*] Contract + Contract(Chair, Staff) + delete(Contract) + hasContract(Chair, Staff): Boolean + contractsOf(Chair): Contract[*] + contractsOf(Staff): Contract[*] + getChair(): Chair + getEmployee(): Staff Managing all contracts via class variable and method of \"Contract\" Alternative: special class \"Contracts\" *1 * 1 chair employee Chair Staff chair employee * * ÔÇÉ works at 46 How to guarantee Multiplicities ‚Ä¢ 0..* and 0..1: No special care needed (as seen before). ‚Ä¢ =1: Set value at object construction; only replace; never set to null! ‚Ä¢ Bounds X..Y: everywhere the attribute is modified, make sure the bounds are not violated. private AcademicEmployee responsible; //=1 private List<Student> students; //X..Y public CourseData(AcademicEmployee responsible, List<Student> students) { this.responsible = responsible; this.students = students; } ... ... public void addStudent(Student s) { if(this.students.size() + 1 <= Y) { this.students.add(s); } } public void removeStudent(Student s) { if(this.student.size() ‚Äì 1 >= X) { this.students.remove(s); } } public void setResponsible( AcademicEmployee responsible) { if(responsible != null) { this.responsible = responsible; } } 47 Implementation of Aggregation and Composition In Java: No differentiation between association, aggregation and composition! Proposed, but not in all terms valid approach: inner classes. Following are some reasons for why not to use inner classes for aggregation and composition. These were not discussed in the lecture and will thus not be relevant for the exam. 48 \"Composition via Inner Classes\": Problem 1 Part cannot be instantiated without whole ‚Ä¢ There has to be an instance of the outer class on which the instance of the inner class can be created ‚Ä¢ No possibility to realize 0..1 multiplicity Whole w = new Whole(); Whole.Part p = w.new Part(); 49 \"Composition via Inner Classes\": Problem 2 \"Part cannot exist without whole\" realized as \"as long as the part exists, the whole exists as well\" ‚Ä¢ If there is no reference on the whole left, the whole continues to exists because of the reference from the part :Whole :Part w p :Whole :Part w :Whole :Partp w = nullp = null 50 \"Composition via Inner Classes\": Problem 3 No propagation of operations ‚Ä¢ Deletion: See problem 2 and the fact that there is no explicit destruction in Java ‚Ä¢ Handing the part to another whole: Since the reference to the whole is compiler-generated, we can not access it class Whole { class Part { } } Whole w = new Whole(); Whole.Part p = w.new Part(); class Whole {...} class Part { public Part(final Whole $this0) { parent = $this0; } } Whole w = new Whole(); Part p = new Part(w); Questions? Sequence Diagrams 53 Sequence Diagrams ‚Ä¢ Visualizes messages along a timeline. ‚Ä¢ Models interaction between ‚Ä¢ Actors and objects ‚Ä¢ Objects among each other ‚Ä¢ An object with itself ‚Ä¢ Represents ‚Ä¢ Dataflow ‚Ä¢ Point in time and duration ‚Ä¢ Branches and loops ‚Ä¢ Parallelism ‚Ä¢ Filtering and asserts :GradeMask Professor <<create>> login Enter grades :System opt [login ok] set(grades) :GradeDB save (grades) 54 :GradeMask Professor login Enter grades :System [login ok] set(grades) :GradeDB save (grades) Elements Actor: same as in use case diagrams. Objects: same as in object diagrams. Lifeline: Timespan in which the objects exist. Message: Invocation of an activity. Actor ObjectLifeline Activation Message Object creation Object destruction Interaction fragment <<create>>opt 55 Elements Activation ‚Ä¢ Timespan in which the object is doing something. Object creation and destruction: ‚Ä¢ Beginning and end of the lifeline. ‚Ä¢ Corresponds to Constructor and Destructor/Garbage Collection :GradeMask Professor login Enter grades :System [login ok] set(grades) :GradeDB save (grades) Actor Object Message <<create>>opt Lifeline Activation Object creation Object destruction Interaction fragment 56 Synchronous vs. Asynchronous Messages Synchronous messages: The caller waits until it receives a response from the callee. Asynchronous messages: The caller continues with their next actions, not waiting on an answer. Possible results are sent back via another asynchronous messages. :A m() :B res :A m() :B waits res No wait, other actions are performed 57 Data Flow Synchronous messages require responses ‚Ä¢ Either implicitly by the end of an activation ‚Ä¢ Or explicitly via response message. There are no response messages for asynchronous messages. Instead, we always must explicitly send back the answer (if there is any) via another message! :A m() :B :A m() :B Implicit Explicit :A m() :B res res = m() answer 58 Syntax An arrow always starts exactly on the edge of the activation that sends this message. The activation that is targeted by the message start exactly at the arrowhead. An activation lasts at least as long as all its nested activations which are call synchronously. :A m() :B :A m() :B :A m() :B Correct Wrong :A m() :B :A m() :B :A m() :B 59 Combined Fragments Complex control structures are realized via interaction fragments. Operator Intention Branches and loops alt Alternative interaction ‚Äì if-then-else opt Optional interaction ‚Äì if-then break Exceptional interaction ‚Äì leaving the enclosing fragment loop Iterative interaction Concurrency and Ordering seq Sequential interaction of weak ordering (default) strict Sequential ordering of strong order par Concurrent interaction critical Atomic interaction Filtering and asserts ignore Irrelevant interaction consider Relevant interaction assert Asserted interaction neg Invalid interaction 60 Combined Fragment Alternative ‚Ä¢ If condition is true, execute upper block, ‚Ä¢ Otherwise execute lower block. ‚Ä¢ May comprise multiple blocks (if-else if- else if‚Ä¶-else) Option: Execute block if condition is true. alt [condition] [else] Action Other action opt [condition] Action 61 Combined Fragment Loop: Repeat block min. a and max. b times. Terminates if condition evaluates to false and at least a runs took place. Break: If condition is true, run action in block and then leave the enclosing block. loop(a,b) [condition] Action break [condition] Action ‚Ä¶ Questions?Summary 64 Elements ‚Ä¢ Interaction partners ‚Ä¢ Passive object ‚Ä¢ Active object (thread) ‚Ä¢ Message ‚Ä¢ synchronous (Caller wait for callee to finish) ‚Ä¢ asynchronous (Caller continues after sending of message) ‚Ä¢ Response message ‚Ä¢ No results ‚Ä¢ With result role: Type role: Type m1 m2 value 65 Elements ‚Ä¢ Object creation message ‚Ä¢ Object destruction message ‚Ä¢ Self-messaging ‚Ä¢ Recursion or ‚Ä¢ Message to object's other subroutines role: Type <<create>> role: Type role: Type <<delete>> Implementation 67 Sequence Diagram ÔÇÑ Code Note: Interaction partners are either passed as arguments or are attributes of the object. :GradeSystem :GradeDB store(grade) class GradeSystem { GradeDB gradedb //= ...; public void enter(Grade grade) { gradedb.store(grade); } } class GradeDB { public void store(Grade grade) { ... return Status.OK; } } sd enter(grade: Grade): void status ok 68 Sequence Diagram ÔÇÑ Code role: Type <<create>> role: Type role: Type <<delete>> ... Type role = new Type(); ... ... delete role; ... ... this.method(); ...method() In C++ and JavaScript*! ... role = null; //or other object ... In Java Also, there must be no other reference to the object. Otherwise, GC will not delete it. 69 Sequence Diagram ÔÇÑ Code alt [condition] [else] Action Other Action opt [condition] Action loop(a,b) [condition] Action break [condition] Action ‚Ä¶ if(condition) { //Action } else { //Other Action } if(condition) { //Action } for(int i = 0; i < b; i++) { if(i >= a && !condition) { break; } //Action } ... { if(condition) { //Action break; //or return; } } Implementation of Activity Diagram 71 Activity Diagram ÔÇÑ Code Activity diagrams are not necessarily coding diagrams. However, we can use them as replacement for control flow diagrams. In this case, each action corresponds to one statement. Two elements that do manifest in code: ‚Ä¢ Decision ‚Äì Merge ‚Ä¢ Fork ‚Äì Join if(condition) { //Action } else { //Other Action } //Here is the merge point [else] [condition] thread.start(); //... thread.join(); 72 Covered UML Diagrams in terms of Implementation ‚Ä¢ Class Diagrams ‚Ä¢ Object Diagrams ‚Ä¢ Sequence Diagrams ‚Ä¢ Activity Diagrams ‚Ä¢ Use Case Diagrams ‚Üí Too complex for specific rules. ‚Ä¢ Component Diagrams ‚Ä¢ State Machine Diagrams This chapter. In design patterns. Incremental Development of a Domain Object Model A domain object model is usually described with class diagrams. 74 Domain Object Model: Abbott's Textual Analysis Mapping of language components to DOM elements: Attention! The output of Abbott's method is nothing close to final! Language element DOM element Example Proper noun / name Object Jim Smith Common noun Class Customer \"is a\", \"is a special kind of\",‚Ä¶ Generalization / Role A professor is also a researcher \"has\", \"contains\", \"comprises\", ‚Ä¶ Aggregation / Composition A module comprises a lecture and an exercise Modal verb (\"must\", \"can\", \"should\") Constraint The number of participants must not exceed 200 students Transitive Verb Method enter Intransitive Verb Event appear Adjective Attribute mandatory 75 The Domain ‚Ä¢ A module comprises up to 2 lecture slots and arbitrary many exercise. A module is part of at least one study program. Lectures and exercises have a certain length, usually 2 hours. The module has a name, a number of credit points given upon completion and a regular term in which the module can be taken. ‚Ä¢ Lectures are conducted by at least one and up to four employees. Employees don't need to give any lecture, but they are allowed to give up to four. ‚Ä¢ Lectures are not limited in size, but exercises are limited to 30 students. ‚Ä¢ An exercise is conducted by a tutor who is a student. Each tutor can hold up to four exercises. ‚Ä¢ Students are enrolled in any number of study programs. ‚Ä¢ We want to keep track of the data of all university members, that is, their name and email address. Student data additionally has their matriculation number, employee data has the social security number additionally. For both categories of university members, we keep separate lists of all entries. 76 Class Diagram: University A module comprises up to 2 lecture slots and arbitrary many exercise. A module is part of at least one study program. Module Lecture Exercise StudyProgram * 1..* * 1 1 0..2 77 Class Diagram: University The module has a name, a number of credit points given upon completion and a regular term in which the module can be taken. Lectures and exercises have a certain length, usually 2 hours. Module - name: String - term: Term - credits: int Lecture - hours: int = 2 Exercise - hours: int = 2 StudyProgram * 1..* * 1 1 0..2 78 Class Diagram: University Lectures are conducted by at least one and up to four employees. Employees don't need to give any lecture, but they are allowed to give up to four. Module - name: String - term: Term - credits: int Lecture - hours: int = 2 Exercise - hours: int = 2 Employee StudyProgram * 0..4 1..* * 1..4 1 1 0..2 79 Class Diagram: University Lectures are not limited in size, but exercises are limited to 30 students. Module - name: String - term: Term - credits: int Lecture - hours: int = 2 Exercise - hours: int = 2 Employee Student StudyProgram * * 0..4 * 1..* * * 1..4 1 1 0..3 0 0..2 80 Class Diagram: University Students are enrolled in any number of study programs. Module - name: String - term: Term - credits: int Lecture - hours: int = 2 Exercise - hours: int = 2 Employee Student StudyProgram * * 0..4 * 1..* 1..* * * 1..4 1 1 * 0..3 0 0..2 81 Class Diagram: University Module - name: String - term: Term - credits: int Lecture - hours: int = 2 Exercise - hours: int = 2 Employee - ssNo: int - fieldOfStudy: String Student - matNo: int UniMember - name: String - email: String StudyProgram * * 0..4 * 1..* 1..* * * 1..4 1 1 * 0..3 0 0..2 We want to keep track of the data of all university members, that is, their name and email address. Student data additionally has their matriculation number, employee data has the social security number and field of study additionally. Questions? Example: Incremental Development of a Sequence Diagram 84 Sequence Diagram: Authentication :AuthStudent 1. The student enters the password. enter password 85 Sequence Diagram: Authentication :Auth :Crypto encode(password) Student 1. The student enters the password. 2. The password is encrypted. encodedPassword enter password 86 Sequence Diagram: Authentication :Auth :Crypto :PasswordDB storedPassword = getPassword(user) Student 1. The student enters the password. 2. The password is encrypted. 3. The encrypted password is read from database. encodedPassword enter password encode(password) 87 Sequence Diagram: Authentication :Auth :Crypto :PasswordDBStudent 1. The student enters the password. 2. The password is encrypted. 3. The encrypted password is read from database. 4. Check if encrypted entered password equals stored password. encodedPassword enter password alt [enteredPassword == storedPassword] [enteredPassword != storedPassword] storedPassword = getPassword(user) encode(password) 88 Sequence Diagram: Authentication :Auth :Crypto :PasswordDBStudent 1. The student enters the password. 2. The password is encrypted. 3. The encrypted password is read from database. 4. Check if encrypted entered password equals stored password. 5. If true: let student enter. Otherwise: show an error message encodedPassword let student enter show error message enter password alt [enteredPassword == storedPassword] [enteredPassword != storedPassword] storedPassword = getPassword(user) encode(password) Questions?","libVersion":"0.3.1","langs":""}